// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Common.DynamicForwardProxy.V2Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto</summary>
  public static partial class DnsCacheReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DnsCacheReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkFlbnZveS9jb25maWcvY29tbW9uL2R5bmFtaWNfZm9yd2FyZF9wcm94eS92",
            "MmFscGhhL2Ruc19jYWNoZS5wcm90bxIxZW52b3kuY29uZmlnLmNvbW1vbi5k",
            "eW5hbWljX2ZvcndhcmRfcHJveHkudjJhbHBoYRoWZW52b3kvYXBpL3YyL2Nk",
            "cy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh5nb29n",
            "bGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRl",
            "LnByb3RvIq0CCg5EbnNDYWNoZUNvbmZpZxIXCgRuYW1lGAEgASgJQgm66cAD",
            "BHICIAESTAoRZG5zX2xvb2t1cF9mYW1pbHkYAiABKA4yJS5lbnZveS5hcGku",
            "djIuQ2x1c3Rlci5EbnNMb29rdXBGYW1pbHlCCrrpwAMFggECEAESPwoQZG5z",
            "X3JlZnJlc2hfcmF0ZRgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlv",
            "bkIKuunAAwWqAQIqABI3Cghob3N0X3R0bBgEIAEoCzIZLmdvb2dsZS5wcm90",
            "b2J1Zi5EdXJhdGlvbkIKuunAAwWqAQIqABI6CgltYXhfaG9zdHMYBSABKAsy",
            "HC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAMEKgIgAEJSCj9p",
            "by5lbnZveXByb3h5LmVudm95LmNvbmZpZy5jb21tb24uZHluYW1pY19mb3J3",
            "YXJkX3Byb3h5LnYyYWxwaGFCDURuc0NhY2hlUHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.CdsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheConfig), global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheConfig.Parser, new[]{ "Name", "DnsLookupFamily", "DnsRefreshRate", "HostTtl", "MaxHosts" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
  /// &lt;arch_overview_http_dynamic_forward_proxy>` for more information.
  /// </summary>
  public sealed partial class DnsCacheConfig : pb::IMessage<DnsCacheConfig> {
    private static readonly pb::MessageParser<DnsCacheConfig> _parser = new pb::MessageParser<DnsCacheConfig>(() => new DnsCacheConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DnsCacheConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Common.DynamicForwardProxy.V2Alpha.DnsCacheReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DnsCacheConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DnsCacheConfig(DnsCacheConfig other) : this() {
      name_ = other.name_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      hostTtl_ = other.hostTtl_ != null ? other.hostTtl_.Clone() : null;
      MaxHosts = other.MaxHosts;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DnsCacheConfig Clone() {
      return new DnsCacheConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the cache. Multiple named caches allow independent dynamic forward proxy
    /// configurations to operate within a single Envoy process using different configurations. All
    /// configurations with the same name *must* otherwise have the same settings when referenced
    /// from different configuration components. Configuration will fail to load if this is not
    /// the case.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 2;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS lookup family to use during resolution.
    ///
    /// [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
    /// way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
    /// then configures a host to have a primary and fall back address. With this, we could very
    /// likely build a "happy eyeballs" connection pool which would race the primary / fall back
    /// address and return the one that wins. This same method could potentially also be used for
    /// QUIC to TCP fall back.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
    ///
    /// .. note:
    ///
    ///  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
    ///  added in a future change.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "host_ttl" field.</summary>
    public const int HostTtlFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration hostTtl_;
    /// <summary>
    /// The TTL for hosts that are unused. Hosts that have not been used in the configured time
    /// interval will be purged. If not specified defaults to 5m.
    ///
    /// .. note:
    ///
    ///   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
    ///   means that if the configured TTL is shorter than the refresh rate the host may not be removed
    ///   immediately.
    ///
    ///  .. note:
    ///
    ///   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration HostTtl {
      get { return hostTtl_; }
      set {
        hostTtl_ = value;
      }
    }

    /// <summary>Field number for the "max_hosts" field.</summary>
    public const int MaxHostsFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_maxHosts_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? maxHosts_;
    /// <summary>
    /// The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
    ///
    /// .. note:
    ///
    ///   The implementation is approximate and enforced independently on each worker thread, thus
    ///   it is possible for the maximum hosts in the cache to go slightly above the configured
    ///   value depending on timing. This is similar to how other circuit breakers work.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxHosts {
      get { return maxHosts_; }
      set {
        maxHosts_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DnsCacheConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DnsCacheConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (!object.Equals(HostTtl, other.HostTtl)) return false;
      if (MaxHosts != other.MaxHosts) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (hostTtl_ != null) hash ^= HostTtl.GetHashCode();
      if (maxHosts_ != null) hash ^= MaxHosts.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HostTtl);
      }
      if (maxHosts_ != null) {
        _single_maxHosts_codec.WriteTagAndValue(output, MaxHosts);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      if (dnsRefreshRate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (hostTtl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostTtl);
      }
      if (maxHosts_ != null) {
        size += _single_maxHosts_codec.CalculateSizeWithTag(MaxHosts);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DnsCacheConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.hostTtl_ != null) {
        if (hostTtl_ == null) {
          HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        HostTtl.MergeFrom(other.HostTtl);
      }
      if (other.maxHosts_ != null) {
        if (maxHosts_ == null || other.MaxHosts != 0) {
          MaxHosts = other.MaxHosts;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 26: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 34: {
            if (hostTtl_ == null) {
              HostTtl = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(HostTtl);
            break;
          }
          case 42: {
            uint? value = _single_maxHosts_codec.Read(input);
            if (maxHosts_ == null || value != 0) {
              MaxHosts = value;
            }
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
