// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/filter/http/ext_authz/v2/ext_authz.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Filter.Http.ExtAuthz.V2 {

  /// <summary>Holder for reflection information generated from envoy/config/filter/http/ext_authz/v2/ext_authz.proto</summary>
  public static partial class ExtAuthzReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/filter/http/ext_authz/v2/ext_authz.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ExtAuthzReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjVlbnZveS9jb25maWcvZmlsdGVyL2h0dHAvZXh0X2F1dGh6L3YyL2V4dF9h",
            "dXRoei5wcm90bxIlZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9hdXRo",
            "ei52MhocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxokZW52b3kvYXBp",
            "L3YyL2NvcmUvZ3JwY19zZXJ2aWNlLnByb3RvGiBlbnZveS9hcGkvdjIvY29y",
            "ZS9odHRwX3VyaS5wcm90bxocZW52b3kvdHlwZS9odHRwX3N0YXR1cy5wcm90",
            "bxofZW52b3kvdHlwZS9tYXRjaGVyL3N0cmluZy5wcm90bxoXdmFsaWRhdGUv",
            "dmFsaWRhdGUucHJvdG8ikAMKCEV4dEF1dGh6EjYKDGdycGNfc2VydmljZRgB",
            "IAEoCzIeLmVudm95LmFwaS52Mi5jb3JlLkdycGNTZXJ2aWNlSAASSgoMaHR0",
            "cF9zZXJ2aWNlGAMgASgLMjIuZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4",
            "dF9hdXRoei52Mi5IdHRwU2VydmljZUgAEhoKEmZhaWx1cmVfbW9kZV9hbGxv",
            "dxgCIAEoCBIVCgl1c2VfYWxwaGEYBCABKAhCAhgBElAKEXdpdGhfcmVxdWVz",
            "dF9ib2R5GAUgASgLMjUuZW52b3kuY29uZmlnLmZpbHRlci5odHRwLmV4dF9h",
            "dXRoei52Mi5CdWZmZXJTZXR0aW5ncxIZChFjbGVhcl9yb3V0ZV9jYWNoZRgG",
            "IAEoCBIvCg9zdGF0dXNfb25fZXJyb3IYByABKAsyFi5lbnZveS50eXBlLkh0",
            "dHBTdGF0dXMSIwobbWV0YWRhdGFfY29udGV4dF9uYW1lc3BhY2VzGAggAygJ",
            "QgoKCHNlcnZpY2VzIlUKDkJ1ZmZlclNldHRpbmdzEiQKEW1heF9yZXF1ZXN0",
            "X2J5dGVzGAEgASgNQgm66cADBCoCIAASHQoVYWxsb3dfcGFydGlhbF9tZXNz",
            "YWdlGAIgASgIIqQCCgtIdHRwU2VydmljZRIuCgpzZXJ2ZXJfdXJpGAEgASgL",
            "MhouZW52b3kuYXBpLnYyLmNvcmUuSHR0cFVyaRITCgtwYXRoX3ByZWZpeBgC",
            "IAEoCRJaChVhdXRob3JpemF0aW9uX3JlcXVlc3QYByABKAsyOy5lbnZveS5j",
            "b25maWcuZmlsdGVyLmh0dHAuZXh0X2F1dGh6LnYyLkF1dGhvcml6YXRpb25S",
            "ZXF1ZXN0ElwKFmF1dGhvcml6YXRpb25fcmVzcG9uc2UYCCABKAsyPC5lbnZv",
            "eS5jb25maWcuZmlsdGVyLmh0dHAuZXh0X2F1dGh6LnYyLkF1dGhvcml6YXRp",
            "b25SZXNwb25zZUoECAMQBEoECAQQBUoECAUQBkoECAYQByKOAQoUQXV0aG9y",
            "aXphdGlvblJlcXVlc3QSPgoPYWxsb3dlZF9oZWFkZXJzGAEgASgLMiUuZW52",
            "b3kudHlwZS5tYXRjaGVyLkxpc3RTdHJpbmdNYXRjaGVyEjYKDmhlYWRlcnNf",
            "dG9fYWRkGAIgAygLMh4uZW52b3kuYXBpLnYyLmNvcmUuSGVhZGVyVmFsdWUi",
            "pwEKFUF1dGhvcml6YXRpb25SZXNwb25zZRJHChhhbGxvd2VkX3Vwc3RyZWFt",
            "X2hlYWRlcnMYASABKAsyJS5lbnZveS50eXBlLm1hdGNoZXIuTGlzdFN0cmlu",
            "Z01hdGNoZXISRQoWYWxsb3dlZF9jbGllbnRfaGVhZGVycxgCIAEoCzIlLmVu",
            "dm95LnR5cGUubWF0Y2hlci5MaXN0U3RyaW5nTWF0Y2hlciKgAQoQRXh0QXV0",
            "aHpQZXJSb3V0ZRIdCghkaXNhYmxlZBgBIAEoCEIJuunAAwRqAggBSAASWgoO",
            "Y2hlY2tfc2V0dGluZ3MYAiABKAsyNC5lbnZveS5jb25maWcuZmlsdGVyLmh0",
            "dHAuZXh0X2F1dGh6LnYyLkNoZWNrU2V0dGluZ3NCCrrpwAMFigECEAFIAEIR",
            "CghvdmVycmlkZRIFuOnAAwEisgEKDUNoZWNrU2V0dGluZ3MSZwoSY29udGV4",
            "dF9leHRlbnNpb25zGAEgAygLMksuZW52b3kuY29uZmlnLmZpbHRlci5odHRw",
            "LmV4dF9hdXRoei52Mi5DaGVja1NldHRpbmdzLkNvbnRleHRFeHRlbnNpb25z",
            "RW50cnkaOAoWQ29udGV4dEV4dGVuc2lvbnNFbnRyeRILCgNrZXkYASABKAkS",
            "DQoFdmFsdWUYAiABKAk6AjgBQkYKM2lvLmVudm95cHJveHkuZW52b3kuY29u",
            "ZmlnLmZpbHRlci5odHRwLmV4dF9hdXRoei52MkINRXh0QXV0aHpQcm90b1AB",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.GrpcServiceReflection.Descriptor, global::Envoy.Api.V2.Core.HttpUriReflection.Descriptor, global::Envoy.Type.HttpStatusReflection.Descriptor, global::Envoy.Type.Matcher.StringReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthz), global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthz.Parser, new[]{ "GrpcService", "HttpService", "FailureModeAllow", "UseAlpha", "WithRequestBody", "ClearRouteCache", "StatusOnError", "MetadataContextNamespaces" }, new[]{ "Services" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings), global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings.Parser, new[]{ "MaxRequestBytes", "AllowPartialMessage" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService), global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService.Parser, new[]{ "ServerUri", "PathPrefix", "AuthorizationRequest", "AuthorizationResponse" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest), global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest.Parser, new[]{ "AllowedHeaders", "HeadersToAdd" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse), global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse.Parser, new[]{ "AllowedUpstreamHeaders", "AllowedClientHeaders" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzPerRoute), global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzPerRoute.Parser, new[]{ "Disabled", "CheckSettings" }, new[]{ "Override" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings), global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings.Parser, new[]{ "ContextExtensions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class ExtAuthz : pb::IMessage<ExtAuthz> {
    private static readonly pb::MessageParser<ExtAuthz> _parser = new pb::MessageParser<ExtAuthz>(() => new ExtAuthz());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExtAuthz> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthz() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthz(ExtAuthz other) : this() {
      failureModeAllow_ = other.failureModeAllow_;
      useAlpha_ = other.useAlpha_;
      withRequestBody_ = other.withRequestBody_ != null ? other.withRequestBody_.Clone() : null;
      clearRouteCache_ = other.clearRouteCache_;
      statusOnError_ = other.statusOnError_ != null ? other.statusOnError_.Clone() : null;
      metadataContextNamespaces_ = other.metadataContextNamespaces_.Clone();
      switch (other.ServicesCase) {
        case ServicesOneofCase.GrpcService:
          GrpcService = other.GrpcService.Clone();
          break;
        case ServicesOneofCase.HttpService:
          HttpService = other.HttpService.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthz Clone() {
      return new ExtAuthz(this);
    }

    /// <summary>Field number for the "grpc_service" field.</summary>
    public const int GrpcServiceFieldNumber = 1;
    /// <summary>
    /// gRPC service configuration (default timeout: 200ms).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.GrpcService GrpcService {
      get { return servicesCase_ == ServicesOneofCase.GrpcService ? (global::Envoy.Api.V2.Core.GrpcService) services_ : null; }
      set {
        services_ = value;
        servicesCase_ = value == null ? ServicesOneofCase.None : ServicesOneofCase.GrpcService;
      }
    }

    /// <summary>Field number for the "http_service" field.</summary>
    public const int HttpServiceFieldNumber = 3;
    /// <summary>
    /// HTTP service configuration (default timeout: 200ms).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService HttpService {
      get { return servicesCase_ == ServicesOneofCase.HttpService ? (global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService) services_ : null; }
      set {
        services_ = value;
        servicesCase_ = value == null ? ServicesOneofCase.None : ServicesOneofCase.HttpService;
      }
    }

    /// <summary>Field number for the "failure_mode_allow" field.</summary>
    public const int FailureModeAllowFieldNumber = 2;
    private bool failureModeAllow_;
    /// <summary>
    ///  Changes filter's behaviour on errors:
    ///
    ///  1. When set to true, the filter will *accept* client request even if the communication with
    ///  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
    ///  error.
    ///
    ///  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
    ///  response if the communication with the authorization service has failed, or if the
    ///  authorization service has returned a HTTP 5xx error.
    ///
    /// Note that errors can be *always* tracked in the :ref:`stats
    /// &lt;config_http_filters_ext_authz_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FailureModeAllow {
      get { return failureModeAllow_; }
      set {
        failureModeAllow_ = value;
      }
    }

    /// <summary>Field number for the "use_alpha" field.</summary>
    public const int UseAlphaFieldNumber = 4;
    private bool useAlpha_;
    /// <summary>
    /// Sets the package version the gRPC service should use. This is particularly
    /// useful when transitioning from alpha to release versions assuming that both definitions are
    /// semantically compatible. Deprecation note: This field is deprecated and should only be used for
    /// version upgrade. See release notes for more details.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseAlpha {
      get { return useAlpha_; }
      set {
        useAlpha_ = value;
      }
    }

    /// <summary>Field number for the "with_request_body" field.</summary>
    public const int WithRequestBodyFieldNumber = 5;
    private global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings withRequestBody_;
    /// <summary>
    /// Enables filter to buffer the client request body and send it within the authorization request.
    /// A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
    /// request message indicating if the body data is partial.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings WithRequestBody {
      get { return withRequestBody_; }
      set {
        withRequestBody_ = value;
      }
    }

    /// <summary>Field number for the "clear_route_cache" field.</summary>
    public const int ClearRouteCacheFieldNumber = 6;
    private bool clearRouteCache_;
    /// <summary>
    /// Clears route cache in order to allow the external authorization service to correctly affect
    /// routing decisions. Filter clears all cached routes when:
    ///
    /// 1. The field is set to *true*.
    ///
    /// 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
    ///
    /// 3. At least one *authorization response header* is added to the client request, or is used for
    /// altering another client request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClearRouteCache {
      get { return clearRouteCache_; }
      set {
        clearRouteCache_ = value;
      }
    }

    /// <summary>Field number for the "status_on_error" field.</summary>
    public const int StatusOnErrorFieldNumber = 7;
    private global::Envoy.Type.HttpStatus statusOnError_;
    /// <summary>
    /// Sets the HTTP status that is returned to the client when there is a network error between the
    /// filter and the authorization server. The default status is HTTP 403 Forbidden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.HttpStatus StatusOnError {
      get { return statusOnError_; }
      set {
        statusOnError_ = value;
      }
    }

    /// <summary>Field number for the "metadata_context_namespaces" field.</summary>
    public const int MetadataContextNamespacesFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_metadataContextNamespaces_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> metadataContextNamespaces_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of metadata namespaces whose values, if present, will be passed to the
    /// ext_authz service as an opaque *protobuf::Struct*.
    ///
    /// For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
    /// &lt;envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtProvider.payload_in_metadata>` is set,
    /// then the following will pass the jwt payload to the authorization server.
    ///
    /// .. code-block:: yaml
    ///
    ///    metadata_context_namespaces:
    ///    - envoy.filters.http.jwt_authn
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> MetadataContextNamespaces {
      get { return metadataContextNamespaces_; }
    }

    private object services_;
    /// <summary>Enum of possible cases for the "services" oneof.</summary>
    public enum ServicesOneofCase {
      None = 0,
      GrpcService = 1,
      HttpService = 3,
    }
    private ServicesOneofCase servicesCase_ = ServicesOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServicesOneofCase ServicesCase {
      get { return servicesCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearServices() {
      servicesCase_ = ServicesOneofCase.None;
      services_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExtAuthz);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExtAuthz other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GrpcService, other.GrpcService)) return false;
      if (!object.Equals(HttpService, other.HttpService)) return false;
      if (FailureModeAllow != other.FailureModeAllow) return false;
      if (UseAlpha != other.UseAlpha) return false;
      if (!object.Equals(WithRequestBody, other.WithRequestBody)) return false;
      if (ClearRouteCache != other.ClearRouteCache) return false;
      if (!object.Equals(StatusOnError, other.StatusOnError)) return false;
      if(!metadataContextNamespaces_.Equals(other.metadataContextNamespaces_)) return false;
      if (ServicesCase != other.ServicesCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (servicesCase_ == ServicesOneofCase.GrpcService) hash ^= GrpcService.GetHashCode();
      if (servicesCase_ == ServicesOneofCase.HttpService) hash ^= HttpService.GetHashCode();
      if (FailureModeAllow != false) hash ^= FailureModeAllow.GetHashCode();
      if (UseAlpha != false) hash ^= UseAlpha.GetHashCode();
      if (withRequestBody_ != null) hash ^= WithRequestBody.GetHashCode();
      if (ClearRouteCache != false) hash ^= ClearRouteCache.GetHashCode();
      if (statusOnError_ != null) hash ^= StatusOnError.GetHashCode();
      hash ^= metadataContextNamespaces_.GetHashCode();
      hash ^= (int) servicesCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (servicesCase_ == ServicesOneofCase.GrpcService) {
        output.WriteRawTag(10);
        output.WriteMessage(GrpcService);
      }
      if (FailureModeAllow != false) {
        output.WriteRawTag(16);
        output.WriteBool(FailureModeAllow);
      }
      if (servicesCase_ == ServicesOneofCase.HttpService) {
        output.WriteRawTag(26);
        output.WriteMessage(HttpService);
      }
      if (UseAlpha != false) {
        output.WriteRawTag(32);
        output.WriteBool(UseAlpha);
      }
      if (withRequestBody_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WithRequestBody);
      }
      if (ClearRouteCache != false) {
        output.WriteRawTag(48);
        output.WriteBool(ClearRouteCache);
      }
      if (statusOnError_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StatusOnError);
      }
      metadataContextNamespaces_.WriteTo(output, _repeated_metadataContextNamespaces_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (servicesCase_ == ServicesOneofCase.GrpcService) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcService);
      }
      if (servicesCase_ == ServicesOneofCase.HttpService) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpService);
      }
      if (FailureModeAllow != false) {
        size += 1 + 1;
      }
      if (UseAlpha != false) {
        size += 1 + 1;
      }
      if (withRequestBody_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WithRequestBody);
      }
      if (ClearRouteCache != false) {
        size += 1 + 1;
      }
      if (statusOnError_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StatusOnError);
      }
      size += metadataContextNamespaces_.CalculateSize(_repeated_metadataContextNamespaces_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExtAuthz other) {
      if (other == null) {
        return;
      }
      if (other.FailureModeAllow != false) {
        FailureModeAllow = other.FailureModeAllow;
      }
      if (other.UseAlpha != false) {
        UseAlpha = other.UseAlpha;
      }
      if (other.withRequestBody_ != null) {
        if (withRequestBody_ == null) {
          WithRequestBody = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings();
        }
        WithRequestBody.MergeFrom(other.WithRequestBody);
      }
      if (other.ClearRouteCache != false) {
        ClearRouteCache = other.ClearRouteCache;
      }
      if (other.statusOnError_ != null) {
        if (statusOnError_ == null) {
          StatusOnError = new global::Envoy.Type.HttpStatus();
        }
        StatusOnError.MergeFrom(other.StatusOnError);
      }
      metadataContextNamespaces_.Add(other.metadataContextNamespaces_);
      switch (other.ServicesCase) {
        case ServicesOneofCase.GrpcService:
          if (GrpcService == null) {
            GrpcService = new global::Envoy.Api.V2.Core.GrpcService();
          }
          GrpcService.MergeFrom(other.GrpcService);
          break;
        case ServicesOneofCase.HttpService:
          if (HttpService == null) {
            HttpService = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService();
          }
          HttpService.MergeFrom(other.HttpService);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Api.V2.Core.GrpcService subBuilder = new global::Envoy.Api.V2.Core.GrpcService();
            if (servicesCase_ == ServicesOneofCase.GrpcService) {
              subBuilder.MergeFrom(GrpcService);
            }
            input.ReadMessage(subBuilder);
            GrpcService = subBuilder;
            break;
          }
          case 16: {
            FailureModeAllow = input.ReadBool();
            break;
          }
          case 26: {
            global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService subBuilder = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.HttpService();
            if (servicesCase_ == ServicesOneofCase.HttpService) {
              subBuilder.MergeFrom(HttpService);
            }
            input.ReadMessage(subBuilder);
            HttpService = subBuilder;
            break;
          }
          case 32: {
            UseAlpha = input.ReadBool();
            break;
          }
          case 42: {
            if (withRequestBody_ == null) {
              WithRequestBody = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.BufferSettings();
            }
            input.ReadMessage(WithRequestBody);
            break;
          }
          case 48: {
            ClearRouteCache = input.ReadBool();
            break;
          }
          case 58: {
            if (statusOnError_ == null) {
              StatusOnError = new global::Envoy.Type.HttpStatus();
            }
            input.ReadMessage(StatusOnError);
            break;
          }
          case 66: {
            metadataContextNamespaces_.AddEntriesFrom(input, _repeated_metadataContextNamespaces_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for buffering the request data.
  /// </summary>
  public sealed partial class BufferSettings : pb::IMessage<BufferSettings> {
    private static readonly pb::MessageParser<BufferSettings> _parser = new pb::MessageParser<BufferSettings>(() => new BufferSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BufferSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BufferSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BufferSettings(BufferSettings other) : this() {
      maxRequestBytes_ = other.maxRequestBytes_;
      allowPartialMessage_ = other.allowPartialMessage_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BufferSettings Clone() {
      return new BufferSettings(this);
    }

    /// <summary>Field number for the "max_request_bytes" field.</summary>
    public const int MaxRequestBytesFieldNumber = 1;
    private uint maxRequestBytes_;
    /// <summary>
    /// Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
    /// *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
    /// set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
    /// &lt;envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.failure_mode_allow>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MaxRequestBytes {
      get { return maxRequestBytes_; }
      set {
        maxRequestBytes_ = value;
      }
    }

    /// <summary>Field number for the "allow_partial_message" field.</summary>
    public const int AllowPartialMessageFieldNumber = 2;
    private bool allowPartialMessage_;
    /// <summary>
    /// When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
    /// The authorization request will be dispatched and no 413 HTTP error will be returned by the
    /// filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowPartialMessage {
      get { return allowPartialMessage_; }
      set {
        allowPartialMessage_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BufferSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BufferSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxRequestBytes != other.MaxRequestBytes) return false;
      if (AllowPartialMessage != other.AllowPartialMessage) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxRequestBytes != 0) hash ^= MaxRequestBytes.GetHashCode();
      if (AllowPartialMessage != false) hash ^= AllowPartialMessage.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxRequestBytes != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(MaxRequestBytes);
      }
      if (AllowPartialMessage != false) {
        output.WriteRawTag(16);
        output.WriteBool(AllowPartialMessage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxRequestBytes != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxRequestBytes);
      }
      if (AllowPartialMessage != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BufferSettings other) {
      if (other == null) {
        return;
      }
      if (other.MaxRequestBytes != 0) {
        MaxRequestBytes = other.MaxRequestBytes;
      }
      if (other.AllowPartialMessage != false) {
        AllowPartialMessage = other.AllowPartialMessage;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxRequestBytes = input.ReadUInt32();
            break;
          }
          case 16: {
            AllowPartialMessage = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// HttpService is used for raw HTTP communication between the filter and the authorization service.
  /// When configured, the filter will parse the client request and use these attributes to call the
  /// authorization server. Depending on the response, the filter may reject or accept the client
  /// request. Note that in any of these events, metadata can be added, removed or overridden by the
  /// filter:
  ///
  /// *On authorization request*, a list of allowed request headers may be supplied. See
  /// :ref:`allowed_headers
  /// &lt;envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.allowed_headers>`
  /// for details. Additional headers metadata may be added to the authorization request. See
  /// :ref:`headers_to_add
  /// &lt;envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>` for
  /// details.
  ///
  /// On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
  /// additional headers metadata may be added to the original client request. See
  /// :ref:`allowed_upstream_headers
  /// &lt;envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`
  /// for details.
  ///
  /// On other authorization response statuses, the filter will not allow traffic. Additional headers
  /// metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
  /// &lt;envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>`
  /// for details.
  /// </summary>
  public sealed partial class HttpService : pb::IMessage<HttpService> {
    private static readonly pb::MessageParser<HttpService> _parser = new pb::MessageParser<HttpService>(() => new HttpService());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpService> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpService() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpService(HttpService other) : this() {
      serverUri_ = other.serverUri_ != null ? other.serverUri_.Clone() : null;
      pathPrefix_ = other.pathPrefix_;
      authorizationRequest_ = other.authorizationRequest_ != null ? other.authorizationRequest_.Clone() : null;
      authorizationResponse_ = other.authorizationResponse_ != null ? other.authorizationResponse_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpService Clone() {
      return new HttpService(this);
    }

    /// <summary>Field number for the "server_uri" field.</summary>
    public const int ServerUriFieldNumber = 1;
    private global::Envoy.Api.V2.Core.HttpUri serverUri_;
    /// <summary>
    /// Sets the HTTP server URI which the authorization requests must be sent to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.HttpUri ServerUri {
      get { return serverUri_; }
      set {
        serverUri_ = value;
      }
    }

    /// <summary>Field number for the "path_prefix" field.</summary>
    public const int PathPrefixFieldNumber = 2;
    private string pathPrefix_ = "";
    /// <summary>
    /// Sets a prefix to the value of authorization request header *Path*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PathPrefix {
      get { return pathPrefix_; }
      set {
        pathPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "authorization_request" field.</summary>
    public const int AuthorizationRequestFieldNumber = 7;
    private global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest authorizationRequest_;
    /// <summary>
    /// Settings used for controlling authorization request metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest AuthorizationRequest {
      get { return authorizationRequest_; }
      set {
        authorizationRequest_ = value;
      }
    }

    /// <summary>Field number for the "authorization_response" field.</summary>
    public const int AuthorizationResponseFieldNumber = 8;
    private global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse authorizationResponse_;
    /// <summary>
    /// Settings used for controlling authorization response metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse AuthorizationResponse {
      get { return authorizationResponse_; }
      set {
        authorizationResponse_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpService);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpService other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ServerUri, other.ServerUri)) return false;
      if (PathPrefix != other.PathPrefix) return false;
      if (!object.Equals(AuthorizationRequest, other.AuthorizationRequest)) return false;
      if (!object.Equals(AuthorizationResponse, other.AuthorizationResponse)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (serverUri_ != null) hash ^= ServerUri.GetHashCode();
      if (PathPrefix.Length != 0) hash ^= PathPrefix.GetHashCode();
      if (authorizationRequest_ != null) hash ^= AuthorizationRequest.GetHashCode();
      if (authorizationResponse_ != null) hash ^= AuthorizationResponse.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (serverUri_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ServerUri);
      }
      if (PathPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PathPrefix);
      }
      if (authorizationRequest_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AuthorizationRequest);
      }
      if (authorizationResponse_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AuthorizationResponse);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (serverUri_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServerUri);
      }
      if (PathPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathPrefix);
      }
      if (authorizationRequest_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorizationRequest);
      }
      if (authorizationResponse_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorizationResponse);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpService other) {
      if (other == null) {
        return;
      }
      if (other.serverUri_ != null) {
        if (serverUri_ == null) {
          ServerUri = new global::Envoy.Api.V2.Core.HttpUri();
        }
        ServerUri.MergeFrom(other.ServerUri);
      }
      if (other.PathPrefix.Length != 0) {
        PathPrefix = other.PathPrefix;
      }
      if (other.authorizationRequest_ != null) {
        if (authorizationRequest_ == null) {
          AuthorizationRequest = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest();
        }
        AuthorizationRequest.MergeFrom(other.AuthorizationRequest);
      }
      if (other.authorizationResponse_ != null) {
        if (authorizationResponse_ == null) {
          AuthorizationResponse = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse();
        }
        AuthorizationResponse.MergeFrom(other.AuthorizationResponse);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (serverUri_ == null) {
              ServerUri = new global::Envoy.Api.V2.Core.HttpUri();
            }
            input.ReadMessage(ServerUri);
            break;
          }
          case 18: {
            PathPrefix = input.ReadString();
            break;
          }
          case 58: {
            if (authorizationRequest_ == null) {
              AuthorizationRequest = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationRequest();
            }
            input.ReadMessage(AuthorizationRequest);
            break;
          }
          case 66: {
            if (authorizationResponse_ == null) {
              AuthorizationResponse = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.AuthorizationResponse();
            }
            input.ReadMessage(AuthorizationResponse);
            break;
          }
        }
      }
    }

  }

  public sealed partial class AuthorizationRequest : pb::IMessage<AuthorizationRequest> {
    private static readonly pb::MessageParser<AuthorizationRequest> _parser = new pb::MessageParser<AuthorizationRequest>(() => new AuthorizationRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AuthorizationRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationRequest(AuthorizationRequest other) : this() {
      allowedHeaders_ = other.allowedHeaders_ != null ? other.allowedHeaders_.Clone() : null;
      headersToAdd_ = other.headersToAdd_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationRequest Clone() {
      return new AuthorizationRequest(this);
    }

    /// <summary>Field number for the "allowed_headers" field.</summary>
    public const int AllowedHeadersFieldNumber = 1;
    private global::Envoy.Type.Matcher.ListStringMatcher allowedHeaders_;
    /// <summary>
    /// Authorization request will include the client request headers that have a correspondent match
    /// in the :ref:`list &lt;envoy_api_msg_type.matcher.ListStringMatcher>`. Note that in addition to the
    /// user's supplied matchers:
    ///
    /// 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
    ///
    /// 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
    /// a message body.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.ListStringMatcher AllowedHeaders {
      get { return allowedHeaders_; }
      set {
        allowedHeaders_ = value;
      }
    }

    /// <summary>Field number for the "headers_to_add" field.</summary>
    public const int HeadersToAddFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValue> _repeated_headersToAdd_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Api.V2.Core.HeaderValue.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValue> headersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValue>();
    /// <summary>
    /// Sets a list of headers that will be included to the request to authorization service. Note that
    /// client request of the same key will be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValue> HeadersToAdd {
      get { return headersToAdd_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AuthorizationRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AuthorizationRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AllowedHeaders, other.AllowedHeaders)) return false;
      if(!headersToAdd_.Equals(other.headersToAdd_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (allowedHeaders_ != null) hash ^= AllowedHeaders.GetHashCode();
      hash ^= headersToAdd_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (allowedHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedHeaders);
      }
      headersToAdd_.WriteTo(output, _repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (allowedHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedHeaders);
      }
      size += headersToAdd_.CalculateSize(_repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AuthorizationRequest other) {
      if (other == null) {
        return;
      }
      if (other.allowedHeaders_ != null) {
        if (allowedHeaders_ == null) {
          AllowedHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
        }
        AllowedHeaders.MergeFrom(other.AllowedHeaders);
      }
      headersToAdd_.Add(other.headersToAdd_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (allowedHeaders_ == null) {
              AllowedHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
            }
            input.ReadMessage(AllowedHeaders);
            break;
          }
          case 18: {
            headersToAdd_.AddEntriesFrom(input, _repeated_headersToAdd_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class AuthorizationResponse : pb::IMessage<AuthorizationResponse> {
    private static readonly pb::MessageParser<AuthorizationResponse> _parser = new pb::MessageParser<AuthorizationResponse>(() => new AuthorizationResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AuthorizationResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationResponse(AuthorizationResponse other) : this() {
      allowedUpstreamHeaders_ = other.allowedUpstreamHeaders_ != null ? other.allowedUpstreamHeaders_.Clone() : null;
      allowedClientHeaders_ = other.allowedClientHeaders_ != null ? other.allowedClientHeaders_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthorizationResponse Clone() {
      return new AuthorizationResponse(this);
    }

    /// <summary>Field number for the "allowed_upstream_headers" field.</summary>
    public const int AllowedUpstreamHeadersFieldNumber = 1;
    private global::Envoy.Type.Matcher.ListStringMatcher allowedUpstreamHeaders_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
    /// response headers that have a correspondent match will be added to the original client request.
    /// Note that coexistent headers will be overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.ListStringMatcher AllowedUpstreamHeaders {
      get { return allowedUpstreamHeaders_; }
      set {
        allowedUpstreamHeaders_ = value;
      }
    }

    /// <summary>Field number for the "allowed_client_headers" field.</summary>
    public const int AllowedClientHeadersFieldNumber = 2;
    private global::Envoy.Type.Matcher.ListStringMatcher allowedClientHeaders_;
    /// <summary>
    /// When this :ref:`list &lt;envoy_api_msg_type.matcher.ListStringMatcher>`. is set, authorization
    /// response headers that have a correspondent match will be added to the client's response. Note
    /// that when this list is *not* set, all the authorization response headers, except *Authority
    /// (Host)* will be in the response to the client. When a header is included in this list, *Path*,
    /// *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.ListStringMatcher AllowedClientHeaders {
      get { return allowedClientHeaders_; }
      set {
        allowedClientHeaders_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AuthorizationResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AuthorizationResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AllowedUpstreamHeaders, other.AllowedUpstreamHeaders)) return false;
      if (!object.Equals(AllowedClientHeaders, other.AllowedClientHeaders)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (allowedUpstreamHeaders_ != null) hash ^= AllowedUpstreamHeaders.GetHashCode();
      if (allowedClientHeaders_ != null) hash ^= AllowedClientHeaders.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (allowedUpstreamHeaders_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AllowedUpstreamHeaders);
      }
      if (allowedClientHeaders_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AllowedClientHeaders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (allowedUpstreamHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedUpstreamHeaders);
      }
      if (allowedClientHeaders_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedClientHeaders);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AuthorizationResponse other) {
      if (other == null) {
        return;
      }
      if (other.allowedUpstreamHeaders_ != null) {
        if (allowedUpstreamHeaders_ == null) {
          AllowedUpstreamHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
        }
        AllowedUpstreamHeaders.MergeFrom(other.AllowedUpstreamHeaders);
      }
      if (other.allowedClientHeaders_ != null) {
        if (allowedClientHeaders_ == null) {
          AllowedClientHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
        }
        AllowedClientHeaders.MergeFrom(other.AllowedClientHeaders);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (allowedUpstreamHeaders_ == null) {
              AllowedUpstreamHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
            }
            input.ReadMessage(AllowedUpstreamHeaders);
            break;
          }
          case 18: {
            if (allowedClientHeaders_ == null) {
              AllowedClientHeaders = new global::Envoy.Type.Matcher.ListStringMatcher();
            }
            input.ReadMessage(AllowedClientHeaders);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Extra settings on a per virtualhost/route/weighted-cluster level.
  /// </summary>
  public sealed partial class ExtAuthzPerRoute : pb::IMessage<ExtAuthzPerRoute> {
    private static readonly pb::MessageParser<ExtAuthzPerRoute> _parser = new pb::MessageParser<ExtAuthzPerRoute>(() => new ExtAuthzPerRoute());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExtAuthzPerRoute> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthzPerRoute() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthzPerRoute(ExtAuthzPerRoute other) : this() {
      switch (other.OverrideCase) {
        case OverrideOneofCase.Disabled:
          Disabled = other.Disabled;
          break;
        case OverrideOneofCase.CheckSettings:
          CheckSettings = other.CheckSettings.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExtAuthzPerRoute Clone() {
      return new ExtAuthzPerRoute(this);
    }

    /// <summary>Field number for the "disabled" field.</summary>
    public const int DisabledFieldNumber = 1;
    /// <summary>
    /// Disable the ext auth filter for this particular vhost or route.
    /// If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Disabled {
      get { return overrideCase_ == OverrideOneofCase.Disabled ? (bool) override_ : false; }
      set {
        override_ = value;
        overrideCase_ = OverrideOneofCase.Disabled;
      }
    }

    /// <summary>Field number for the "check_settings" field.</summary>
    public const int CheckSettingsFieldNumber = 2;
    /// <summary>
    /// Check request settings for this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings CheckSettings {
      get { return overrideCase_ == OverrideOneofCase.CheckSettings ? (global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings) override_ : null; }
      set {
        override_ = value;
        overrideCase_ = value == null ? OverrideOneofCase.None : OverrideOneofCase.CheckSettings;
      }
    }

    private object override_;
    /// <summary>Enum of possible cases for the "override" oneof.</summary>
    public enum OverrideOneofCase {
      None = 0,
      Disabled = 1,
      CheckSettings = 2,
    }
    private OverrideOneofCase overrideCase_ = OverrideOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OverrideOneofCase OverrideCase {
      get { return overrideCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOverride() {
      overrideCase_ = OverrideOneofCase.None;
      override_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExtAuthzPerRoute);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExtAuthzPerRoute other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Disabled != other.Disabled) return false;
      if (!object.Equals(CheckSettings, other.CheckSettings)) return false;
      if (OverrideCase != other.OverrideCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (overrideCase_ == OverrideOneofCase.Disabled) hash ^= Disabled.GetHashCode();
      if (overrideCase_ == OverrideOneofCase.CheckSettings) hash ^= CheckSettings.GetHashCode();
      hash ^= (int) overrideCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (overrideCase_ == OverrideOneofCase.Disabled) {
        output.WriteRawTag(8);
        output.WriteBool(Disabled);
      }
      if (overrideCase_ == OverrideOneofCase.CheckSettings) {
        output.WriteRawTag(18);
        output.WriteMessage(CheckSettings);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (overrideCase_ == OverrideOneofCase.Disabled) {
        size += 1 + 1;
      }
      if (overrideCase_ == OverrideOneofCase.CheckSettings) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CheckSettings);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExtAuthzPerRoute other) {
      if (other == null) {
        return;
      }
      switch (other.OverrideCase) {
        case OverrideOneofCase.Disabled:
          Disabled = other.Disabled;
          break;
        case OverrideOneofCase.CheckSettings:
          if (CheckSettings == null) {
            CheckSettings = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings();
          }
          CheckSettings.MergeFrom(other.CheckSettings);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Disabled = input.ReadBool();
            break;
          }
          case 18: {
            global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings subBuilder = new global::Envoy.Config.Filter.Http.ExtAuthz.V2.CheckSettings();
            if (overrideCase_ == OverrideOneofCase.CheckSettings) {
              subBuilder.MergeFrom(CheckSettings);
            }
            input.ReadMessage(subBuilder);
            CheckSettings = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Extra settings for the check request. You can use this to provide extra context for the
  /// external authorization server on specific virtual hosts \ routes. For example, adding a context
  /// extension on the virtual host level can give the ext-authz server information on what virtual
  /// host is used without needing to parse the host header. If CheckSettings is specified in multiple
  /// per-filter-configs, they will be merged in order, and the result will be used.
  /// </summary>
  public sealed partial class CheckSettings : pb::IMessage<CheckSettings> {
    private static readonly pb::MessageParser<CheckSettings> _parser = new pb::MessageParser<CheckSettings>(() => new CheckSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CheckSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Http.ExtAuthz.V2.ExtAuthzReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckSettings(CheckSettings other) : this() {
      contextExtensions_ = other.contextExtensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckSettings Clone() {
      return new CheckSettings(this);
    }

    /// <summary>Field number for the "context_extensions" field.</summary>
    public const int ContextExtensionsFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_contextExtensions_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 10);
    private readonly pbc::MapField<string, string> contextExtensions_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Context extensions to set on the CheckRequest's
    /// :ref:`AttributeContext.context_extensions&lt;envoy_api_field_service.auth.v2.AttributeContext.context_extensions>`
    ///
    /// Merge semantics for this field are such that keys from more specific configs override.
    ///
    /// .. note::
    ///
    ///   These settings are only applied to a filter configured with a
    ///   :ref:`grpc_service&lt;envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.grpc_service>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ContextExtensions {
      get { return contextExtensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CheckSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CheckSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!ContextExtensions.Equals(other.ContextExtensions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ContextExtensions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      contextExtensions_.WriteTo(output, _map_contextExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += contextExtensions_.CalculateSize(_map_contextExtensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CheckSettings other) {
      if (other == null) {
        return;
      }
      contextExtensions_.Add(other.contextExtensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            contextExtensions_.AddEntriesFrom(input, _map_contextExtensions_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
